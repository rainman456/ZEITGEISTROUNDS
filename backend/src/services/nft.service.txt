// import { PublicKey, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';
// import BN from 'bn.js';
// import { ProgramService } from '../blockchain/program';
// import { PDAService } from '../blockchain/pdas';
// import { SolanaConfig } from '../config/solana.config';

// export interface MomentCardMetadata {
//   roundId: number;
//   question: string;
//   userOutcome: number;
//   userAmount: number;
//   isWinner: boolean;
//   winningOutcome: number;
//   totalPool: number;
//   winningPool: number;
//   timestamp: number;
//   rarity: string;
// }

// export interface MintResult {
//   signature: string;
//   roundId: number;
//   user: string;
//   rarity: string;
//   metadata: MomentCardMetadata;
// }

// export class NFTService {
//   private programService: ProgramService;
//   private pdaService: PDAService;
//   private config: SolanaConfig;

//   // Metaplex Bubblegum Program ID (cNFT standard)
//   private readonly BUBBLEGUM_PROGRAM_ID = new PublicKey(
//     'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY'
//   );

//   // SPL Account Compression Program ID
//   private readonly COMPRESSION_PROGRAM_ID = new PublicKey(
//     'cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK'
//   );

//   // SPL Noop Program ID
//   private readonly NOOP_PROGRAM_ID = new PublicKey(
//     'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV'
//   );

//   constructor() {
//     this.programService = ProgramService.getInstance();
//     this.pdaService = new PDAService();
//     this.config = SolanaConfig.getInstance();
//   }

//   /**
//    * Calculate rarity based on winning percentage
//    */
//   private calculateRarity(winningPool: number, totalPool: number, isWinner: boolean): string {
//     if (!isWinner) {
//       return 'Common'; // Losing predictions are common
//     }

//     if (totalPool === 0) {
//       return 'Common';
//     }

//     const winPercentage = (winningPool * 100) / totalPool;

//     if (winPercentage < 10) {
//       return 'Legendary'; // Less than 10% of pool on winning side
//     } else if (winPercentage < 25) {
//       return 'Epic'; // 10-25% of pool
//     } else if (winPercentage < 40) {
//       return 'Rare'; // 25-40% of pool
//     } else {
//       return 'Uncommon'; // 40%+ of pool
//     }
//   }

//   /**
//    * Check if user can mint a moment card for a round
//    */
//   public async canMintMomentCard(roundId: number, userPubkey?: PublicKey): Promise<{
//     canMint: boolean;
//     reason?: string;
//     metadata?: MomentCardMetadata;
//   }> {
//     try {
//       const user = userPubkey || this.config.payerKeypair.publicKey;

//       // Get round data
//       const round = await this.programService.getRound(roundId);
//       if (!round) {
//         return {
//           canMint: false,
//           reason: 'Round not found',
//         };
//       }

//       // Check if round is settled
//       const status = Object.keys(round.data.status)[0];
//       if (status !== 'settled') {
//         return {
//           canMint: false,
//           reason: `Round not settled (status: ${status})`,
//         };
//       }

//       // Get user's prediction
//       const prediction = await this.programService.getPrediction(roundId, user);
//       if (!prediction) {
//         return {
//           canMint: false,
//           reason: 'No prediction found for this user',
//         };
//       }

//       // Check if user participated
//       const isWinner = prediction.data.outcome === round.data.winningOutcome;
//       const rarity = this.calculateRarity(
//         round.data.winningPool.toNumber(),
//         round.data.totalPool.toNumber(),
//         isWinner
//       );

//       const metadata: MomentCardMetadata = {
//         roundId,
//         question: round.data.question,
//         userOutcome: prediction.data.outcome,
//         userAmount: prediction.data.amount.toNumber(),
//         isWinner,
//         winningOutcome: round.data.winningOutcome,
//         totalPool: round.data.totalPool.toNumber(),
//         winningPool: round.data.winningPool.toNumber(),
//         timestamp: prediction.data.timestamp.toNumber(),
//         rarity,
//       };

//       return {
//         canMint: true,
//         metadata,
//       };

//     } catch (error) {
//       return {
//         canMint: false,
//         reason: `Error checking eligibility: ${error}`,
//       };
//     }
//   }

//   /**
//    * Mint a moment card NFT for a settled round
//    * 
//    * NOTE: This is a MOCK implementation for the prototype.
//    * Full production implementation requires:
//    * 1. Metaplex Bubblegum merkle tree setup
//    * 2. Collection NFT creation
//    * 3. Proper metadata upload to Arweave/IPFS
//    * 4. Tree authority configuration
//    */
//   public async mintMomentCard(roundId: number, userPubkey?: PublicKey): Promise<MintResult> {
//     try {
//       const user = userPubkey || this.config.payerKeypair.publicKey;

//       console.log(`\nğŸ¨ Minting Moment Card for round ${roundId}...`);
//       console.log(`  User: ${user.toBase58()}`);

//       // Check if user can mint
//       const eligibility = await this.canMintMomentCard(roundId, user);
//       if (!eligibility.canMint) {
//         throw new Error(`Cannot mint moment card: ${eligibility.reason}`);
//       }

//       const metadata = eligibility.metadata!;
//       console.log(`  Rarity: ${metadata.rarity}`);
//       console.log(`  Winner: ${metadata.isWinner ? 'YES' : 'NO'}`);

//       // MOCK: In production, you would:
//       // 1. Create/fetch Merkle tree
//       // 2. Upload metadata to Arweave/IPFS
//       // 3. Call mint_moment_card instruction

//       console.log('\nâš ï¸  NFT Minting: MOCK MODE');
//       console.log('  Production implementation requires:');
//       console.log('  1. Metaplex Bubblegum merkle tree');
//       console.log('  2. Collection NFT setup');
//       console.log('  3. Metadata hosting (Arweave/IPFS)');
//       console.log('  4. Tree authority configuration');

//       // For prototype, we simulate the mint
//       const mockSignature = `MOCK_NFT_${roundId}_${user.toBase58().slice(0, 8)}`;
      
//       console.log(`\nâœ… Moment Card minted (MOCK)!`);
//       console.log(`ğŸ“ Mock Signature: ${mockSignature}`);
//       console.log(`ğŸ¨ Rarity: ${metadata.rarity}`);
//       console.log(`ğŸ† Result: ${metadata.isWinner ? 'WINNER' : 'PARTICIPATED'}`);

//       // NOTE: Actual smart contract call would look like this:
//       /*
//       const [roundPda] = this.pdaService.getRoundPDA(roundId);
//       const [predictionPda] = this.pdaService.getPredictionPDA(roundId, user);

//       const signature = await this.programService.program.methods
//         .mintMomentCard(new BN(roundId))
//         .accounts({
//           round: roundPda,
//           prediction: predictionPda,
//           merkleTree: merkleTreePubkey,
//           treeAuthority: treeAuthorityPubkey,
//           collectionMint: collectionMintPubkey,
//           collectionMetadata: collectionMetadataPubkey,
//           collectionEdition: collectionEditionPubkey,
//           user: user,
//           bubblegumProgram: this.BUBBLEGUM_PROGRAM_ID,
//           compressionProgram: this.COMPRESSION_PROGRAM_ID,
//           logWrapper: this.NOOP_PROGRAM_ID,
//           systemProgram: SystemProgram.programId,
//         })
//         .rpc();

//       await this.config.connection.confirmTransaction(signature, 'confirmed');
//       */

//       return {
//         signature: mockSignature,
//         roundId,
//         user: user.toBase58(),
//         rarity: metadata.rarity,
//         metadata,
//       };

//     } catch (error) {
//       console.error('âŒ Failed to mint moment card:', error);
//       throw error;
//     }
//   }

//   /**
//    * Get all moment cards for a user (mock implementation)
//    */
//   public async getUserMomentCards(userPubkey?: PublicKey): Promise<MomentCardMetadata[]> {
//     try {
//       const user = userPubkey || this.config.payerKeypair.publicKey;

//       console.log(`\nğŸ” Fetching moment cards for user: ${user.toBase58()}`);

//       // Get all user predictions
//       const allPredictions = await (this.programService.program.account as any)['prediction'].all();
      
//       const userPredictions = allPredictions.filter((pred: any) => 
//         pred.account.user.equals(user)
//       );

//       console.log(`  Found ${userPredictions.length} prediction(s)`);

//       const momentCards: MomentCardMetadata[] = [];

//       for (const pred of userPredictions) {
//         const roundId = pred.account.roundId.toNumber();
//         const eligibility = await this.canMintMomentCard(roundId, user);
        
//         // Only include settled rounds where user participated
//         if (eligibility.canMint && eligibility.metadata) {
//           momentCards.push(eligibility.metadata);
//         }
//       }

//       return momentCards;

//     } catch (error) {
//       console.error('Failed to fetch user moment cards:', error);
//       return [];
//     }
//   }

//   /**
//    * Generate metadata URI for moment card
//    */
//   public generateMetadataURI(roundId: number, userPubkey: PublicKey): string {
//     // In production, this would point to hosted metadata on Arweave/IPFS
//     return `https://api.zeitgeist.game/moments/${roundId}/${userPubkey.toBase58()}`;
//   }

//   /**
//    * Format moment card metadata for display
//    */
//   public formatMomentCard(metadata: MomentCardMetadata): string {
//     return `
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              ZEITGEIST MOMENT CARD                     â•‘
// â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
// â•‘ Round ID: ${metadata.roundId.toString().padEnd(43)} â•‘
// â•‘ Question: ${metadata.question.slice(0, 43).padEnd(43)} â•‘
// â•‘                                                        â•‘
// â•‘ Your Prediction: ${(metadata.userOutcome === 0 ? 'YES' : 'NO').padEnd(37)} â•‘
// â•‘ Amount Wagered: ${(metadata.userAmount / LAMPORTS_PER_SOL).toFixed(4)} SOL${' '.repeat(28)} â•‘
// â•‘                                                        â•‘
// â•‘ Result: ${(metadata.isWinner ? 'ğŸ† WINNER' : 'âŒ LOSS').padEnd(45)} â•‘
// â•‘ Winning Outcome: ${(metadata.winningOutcome === 0 ? 'YES' : 'NO').padEnd(38)} â•‘
// â•‘                                                        â•‘
// â•‘ Pool Stats:                                            â•‘
// â•‘   Total Pool: ${(metadata.totalPool / LAMPORTS_PER_SOL).toFixed(4)} SOL${' '.repeat(29)} â•‘
// â•‘   Winning Pool: ${(metadata.winningPool / LAMPORTS_PER_SOL).toFixed(4)} SOL${' '.repeat(27)} â•‘
// â•‘                                                        â•‘
// â•‘ Rarity: â­ ${metadata.rarity.toUpperCase().padEnd(40)} â•‘
// â•‘ Date: ${new Date(metadata.timestamp * 1000).toISOString().slice(0, 10).padEnd(45)} â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//     `;
//   }

//   /**
//    * Get rarity distribution for all minted cards
//    */
//   public async getRarityDistribution(): Promise<{
//     legendary: number;
//     epic: number;
//     rare: number;
//     uncommon: number;
//     common: number;
//   }> {
//     try {
//       // Get all settled rounds
//       const allRounds = await (this.programService.program.account as any)['round'].all();
      
//       const settledRounds = allRounds.filter((round: any) => {
//         const status = Object.keys(round.account.status)[0];
//         return status === 'settled';
//       });

//       const distribution = {
//         legendary: 0,
//         epic: 0,
//         rare: 0,
//         uncommon: 0,
//         common: 0,
//       };

//       for (const round of settledRounds) {
//         const winningPool = round.account.winningPool.toNumber();
//         const totalPool = round.account.totalPool.toNumber();
        
//         const rarity = this.calculateRarity(winningPool, totalPool, true);
        
//         switch (rarity) {
//           case 'Legendary':
//             distribution.legendary++;
//             break;
//           case 'Epic':
//             distribution.epic++;
//             break;
//           case 'Rare':
//             distribution.rare++;
//             break;
//           case 'Uncommon':
//             distribution.uncommon++;
//             break;
//           case 'Common':
//             distribution.common++;
//             break;
//         }
//       }

//       return distribution;

//     } catch (error) {
//       return {
//         legendary: 0,
//         epic: 0,
//         rare: 0,
//         uncommon: 0,
//         common: 0,
//       };
//     }
//   }

//   // Embedded test method
//   public static async __test(): Promise<boolean> {
//     console.log('\nğŸ§ª Testing NFT Moment Card Service...\n');

//     try {
//       const nftService = new NFTService();
//       const config = SolanaConfig.getInstance();

//       // Test 1: Setup - Create and settle a round with prediction
//       console.log('Test 1: Setting up settled round with prediction...');
      
//       const { RoundService, VerificationMethod } = await import('./round.service');
//       const { PredictionService } = await import('./prediction.service');
//       const { SettlementService } = await import('./settlement.service');
      
//       const roundService = new RoundService();
//       const predictionService = new PredictionService();
//       const settlementService = new SettlementService();

//       const now = Math.floor(Date.now() / 1000);
//       const startTime = now + 5;
//       const endTime = startTime + 60;

//       const testRound = await roundService.createRound({
//         question: 'NFT Test: Will SOL > $150?',
//         startTime,
//         endTime,
//         numOutcomes: 2,
//         verificationType: VerificationMethod.OnChainData,
//         targetValue: 15000,
//         dataSource: config.payerKeypair.publicKey,
//         oracle: config.payerKeypair.publicKey,
//       });

//       console.log(`âœ“ Test round created: ${testRound.roundId}`);

//       // Wait for betting window
//       const waitTime = (startTime - now + 2) * 1000;
//       if (waitTime > 0) {
//         console.log(`  Waiting ${waitTime / 1000}s for betting to open...`);
//         await new Promise(resolve => setTimeout(resolve, waitTime));
//       }

//       // Place a bet
//       const betAmount = 0.1 * LAMPORTS_PER_SOL;
//       await predictionService.placePrediction({
//         roundId: testRound.roundId,
//         outcome: 0, // YES
//         amount: betAmount,
//       });

//       console.log(`âœ“ Placed bet: ${betAmount / LAMPORTS_PER_SOL} SOL`);

//       // Wait for round to end
//       const timeUntilEnd = endTime - Math.floor(Date.now() / 1000) + 2;
//       if (timeUntilEnd > 0) {
//         console.log(`  Waiting ${timeUntilEnd}s for round to end...`);
//         await new Promise(resolve => setTimeout(resolve, timeUntilEnd * 1000));
//       }

//       // Close and settle
//       await settlementService.closeBetting(testRound.roundId);
//       await new Promise(resolve => setTimeout(resolve, 2000));

//       const winningOutcome = 0; // YES wins
//       const winningPoolAmount = await settlementService.calculateWinningPool(
//         testRound.roundId,
//         winningOutcome
//       );

//       await settlementService.settleRound({
//         roundId: testRound.roundId,
//         winningPoolAmount,
//       });

//       console.log('âœ“ Round settled');

//       await new Promise(resolve => setTimeout(resolve, 2000));

//       // Test 2: Check if user can mint
//       console.log('\nTest 2: Checking NFT minting eligibility...');
//       const eligibility = await nftService.canMintMomentCard(testRound.roundId);
      
//       if (!eligibility.canMint) {
//         throw new Error(`Cannot mint: ${eligibility.reason}`);
//       }

//       console.log('âœ“ User is eligible to mint');
//       console.log(`  Rarity: ${eligibility.metadata?.rarity}`);
//       console.log(`  Winner: ${eligibility.metadata?.isWinner}`);

//       // Test 3: Mint moment card
//       console.log('\nTest 3: Minting moment card...');
//       const mintResult = await nftService.mintMomentCard(testRound.roundId);

//       console.log('âœ“ Moment card minted successfully');
//       console.log(`  Rarity: ${mintResult.rarity}`);
//       console.log(`  Signature: ${mintResult.signature}`);

//       // Test 4: Format and display moment card
//       console.log('\nTest 4: Displaying moment card...');
//       console.log(nftService.formatMomentCard(mintResult.metadata));

//       // Test 5: Get all user moment cards
//       console.log('Test 5: Fetching all user moment cards...');
//       const userCards = await nftService.getUserMomentCards();
//       console.log(`âœ“ Found ${userCards.length} moment card(s) available`);

//       if (userCards.length > 0) {
//         console.log('\nUser Moment Cards:');
//         for (let i = 0; i < Math.min(3, userCards.length); i++) {
//           const card = userCards[i];
//           console.log(`\n  Card ${i + 1}:`);
//           console.log(`    Round: ${card.roundId}`);
//           console.log(`    Question: ${card.question.slice(0, 40)}...`);
//           console.log(`    Rarity: ${card.rarity}`);
//           console.log(`    Result: ${card.isWinner ? 'Winner' : 'Participated'}`);
//         }
//       }

//       // Test 6: Rarity calculation tests
//       console.log('\nTest 6: Testing rarity calculation...');
      
//       const rarityTests = [
//         { winningPool: 5, totalPool: 100, expected: 'Legendary' }, // 5%
//         { winningPool: 15, totalPool: 100, expected: 'Epic' },      // 15%
//         { winningPool: 30, totalPool: 100, expected: 'Rare' },      // 30%
//         { winningPool: 45, totalPool: 100, expected: 'Uncommon' },  // 45%
//       ];

//       for (const test of rarityTests) {
//         const rarity = nftService['calculateRarity'](test.winningPool, test.totalPool, true);
//         if (rarity !== test.expected) {
//           throw new Error(`Rarity calculation failed: expected ${test.expected}, got ${rarity}`);
//         }
//         console.log(`  âœ“ ${test.winningPool}/${test.totalPool} pool = ${rarity}`);
//       }

//       // Test 7: Losers get Common rarity
//       console.log('\nTest 7: Testing loser rarity...');
//       const loserRarity = nftService['calculateRarity'](10, 100, false);
//       if (loserRarity !== 'Common') {
//         throw new Error(`Expected Common for losers, got ${loserRarity}`);
//       }
//       console.log('âœ“ Losers correctly get Common rarity');

//       // Test 8: Rarity distribution
//       console.log('\nTest 8: Getting rarity distribution...');
//       const distribution = await nftService.getRarityDistribution();
//       console.log('âœ“ Rarity distribution:');
//       console.log(`  Legendary: ${distribution.legendary}`);
//       console.log(`  Epic: ${distribution.epic}`);
//       console.log(`  Rare: ${distribution.rare}`);
//       console.log(`  Uncommon: ${distribution.uncommon}`);
//       console.log(`  Common: ${distribution.common}`);

//       // Test 9: Metadata URI generation
//       console.log('\nTest 9: Testing metadata URI generation...');
//       const metadataURI = nftService.generateMetadataURI(
//         testRound.roundId,
//         config.payerKeypair.publicKey
//       );
//       console.log(`âœ“ Metadata URI: ${metadataURI}`);

//       if (!metadataURI.includes(testRound.roundId.toString())) {
//         throw new Error('Metadata URI should include round ID');
//       }

//       // Test 10: Try to mint for non-settled round (should fail)
//       console.log('\nTest 10: Testing mint prevention for non-settled round...');
      
//       const futureRound = await roundService.createRound({
//         question: 'Future round',
//         startTime: now + 300,
//         endTime: now + 360,
//         numOutcomes: 2,
//         verificationType: VerificationMethod.OnChainData,
//         targetValue: 15000,
//         dataSource: config.payerKeypair.publicKey,
//         oracle: config.payerKeypair.publicKey,
//       });

//       const futureEligibility = await nftService.canMintMomentCard(futureRound.roundId);
      
//       if (futureEligibility.canMint) {
//         throw new Error('Should not be able to mint for unsettled round');
//       }

//       console.log('âœ“ Correctly prevented minting for unsettled round');
//       console.log(`  Reason: ${futureEligibility.reason}`);

//       console.log('\n' + '='.repeat(60));
//       console.log('âœ… All NFT Moment Card Service tests passed!');
//       console.log('='.repeat(60));
//       console.log('\nğŸ’¡ NFT Service features:');
//       console.log('   - Eligibility checking: âœ…');
//       console.log('   - Rarity calculation: âœ…');
//       console.log('   - Moment card minting (mock): âœ…');
//       console.log('   - User card collection: âœ…');
//       console.log('   - Metadata generation: âœ…');
//       console.log('   - Display formatting: âœ…');
//       console.log('\nğŸ“ Note: Full production implementation requires:');
//       console.log('   1. Metaplex Bubblegum setup');
//       console.log('   2. Merkle tree configuration');
//       console.log('   3. Collection NFT creation');
//       console.log('   4. Metadata hosting (Arweave/IPFS)');

//       return true;

//     } catch (error) {
//       console.error('\nâŒ NFT Service test failed:', error);

//       if (error instanceof Error) {
//         console.error('Error details:', error.message);

//         // Helpful error messages
//         if (error.message.includes('RoundNotSettled')) {
//           console.error('\nğŸ’¡ Fix: Round must be settled before minting NFTs');
//         } else if (error.message.includes('No prediction found')) {
//           console.error('\nğŸ’¡ Fix: User must have participated in the round');
//         }
//       }

//       return false;
//     }
//   }
// }